package tasks

import (
	"fmt"
	"sync"
	"time"
)

/*
7. Реализовать конкурентную запись данных в map.
*/

func Task7() {
	// Карты небезопасны для конкурентного использования: не определено, что происходит, когда вы читаете и
	// пишете в них одновременно. Если вам нужно читать и записывать на карту из конкурентно выполняемых
	// go-процедур (goroutines), доступ должен быть обеспечен каким-то механизмом синхронизации.
	var counters = map[int]int{}
	// использовать по ссылке
	mu := &sync.Mutex{}

	// создаем 5 горутин
	for i := 0; i < 5; i++ {
		go func(counters map[int]int, i int, mu *sync.Mutex) {
			for j := 0; j < 5; j++ {
				// блокируем доступ другим горутинам к критической секции
				mu.Lock()
				counters[i*10+j]++
				// снимаем блокировку
				mu.Unlock()
			}
		}(counters, i, mu)
	}

	time.Sleep(time.Second)

	// если не проверять, завершилась ли работа горутин, то для чтения также блокируем вывод:
	// например, можно дождаться окончания работы с помощью WaitGroup
	mu.Lock()
	fmt.Println("counters result", counters)
	mu.Unlock()

	// RWMutex - это блокировка взаимного исключения чтения / записи.  Блокировку может удерживать произвольное количество читателей
	// или один писатель.  Нулевое значение для RWMutex - это разблокированный мьютекс.
	// Другими словами, читателям не нужно ждать друг друга.  Им остается только дождаться писателей, удерживающих Lock.
	// Таким образом, sync.RWMutex предпочтительнее для данных, которые в основном читаются

	// 2 способ: использование sync.RWMutex
	muRW := &sync.RWMutex{}
	var counters2 = make(map[int]int)
	for i := 0; i < 3; i++ {
		go func(counters2 *map[int]int, i int, muRW *sync.RWMutex) {
			for j := 0; j < 3; j++ {
				// блокируем для чтения доступ другим горутинам к критической секции
				muRW.RLock()
				fmt.Printf("%d ", (*counters2)[0])
				muRW.RUnlock()

				// для записи используем блокировку записи
				muRW.Lock()
				(*counters2)[i]++
				muRW.Unlock()
			}
		}(&counters2, i, muRW)
	}

	time.Sleep(time.Second)

	// если не проверять, завершилась ли работа горутин, то для чтения также блокируем вывод:
	// например, можно дождаться окончания работы с помощью WaitGroup
	muRW.RLock()
	fmt.Println("counters2 result", counters2)
	muRW.RUnlock()
}
