package tasks

import (
	"fmt"
	"sync"
	"time"
)

/*
5. Разработать программу, которая будет последовательно отправлять значения в канал,
 а с другой стороны канала — читать. По истечению N секунд программа должна завершаться
*/

func Task5() {
	const (
		N = 3 // количество секунд
	)

	// можем использовать небуферизированный канал, т.к. "синхронно" пишем и читаем
	workerInput := make(chan int)

	// выход из программы по таймеру
	timer := time.NewTimer(N * time.Second)

	// Используем WaitGroup для ожидания завершения горутины (убеждаемся, что ресурсы освобождены)
	wg := &sync.WaitGroup{}
	wg.Add(1)

	// горутина для чтения из канала
	go func() {
		for {
			// num - значение из канала, а more = false, если канал закрыт
			num, more := <-workerInput
			if more {
				// канал открыт: выполняем полезную работу
				fmt.Printf("Value from goroutine: %ds\n", num)
			} else {
				// канал закрыт: выводим сообщение и выходим из горутины
				fmt.Printf("Goroutine job is done \n")

				// сообщаем о завершении работы
				wg.Done()
				return
			}
		}
	}()

	// постоянная запись данных в канал из главного потока
	// метка необходима, чтобы выйти из select и for {}
	// Область видимости метки - это тело функции, в которой она объявлена, и исключает тело любой вложенной функции.
mainLoop:
	for {
		// для работы с каналом (от таймера) используем select
		select {

		// событие от таймера в канале timer.C
		case <-timer.C:
			fmt.Printf("Timeout!\n")
			// закрываем канал, уведомляя горутину о завершении работы
			close(workerInput)
			// завершаем работу внешнего цикла под меткой! а не всего блока mainLoop
			break mainLoop

		// если таймер еще не сработал - посылаем в канал данные
		default:
			workerInput <- time.Now().Second()
			time.Sleep(time.Second)
		}
	}

	wg.Wait()
	fmt.Println("Task5. Finish")
}
